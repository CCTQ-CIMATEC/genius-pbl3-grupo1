module hazard_unit (
    input  logic       i_memread_e,       // Load: MEM
    input  logic [4:0] i_rd_addr_e,       // ex register
    input  logic [4:0] i_rs1_addr_d,      
    input  logic [4:0] i_rs2_addr_d,      

    input  logic       i_regwrite_m,
    input  logic [4:0] i_rd_addr_m,
    input  logic       i_regwrite_w,
    input  logic [4:0] i_rd_addr_w,

    output logic       o_stall,           // if its meant to stall
    output logic [1:0] o_forward_a,
    output logic [1:0] o_forward_b
);

    // stall
    assign o_stall = (i_memread_e &&
                    ((i_rd_addr_e == i_rs1_addr_d) || (i_rd_addr_e == i_rs2_addr_d))) ? 1 : 0;

    // logic forwarding
    always_comb begin
        // Default: sem forwarding
        o_forward_a = 2'b00;
        o_forward_b = 2'b00;

        // EX hazard (MEM stage)
        if (i_regwrite_m && (i_rd_addr_m != 0) && (i_rd_addr_m == i_rs1_addr_d))
            o_forward_a = 2'b10;
        if (i_regwrite_m && (i_rd_addr_m != 0) && (i_rd_addr_m == i_rs2_addr_d))
            o_forward_b = 2'b10;

        // WB hazard
        if (i_regwrite_w && (i_rd_addr_w != 0) &&
            !(i_regwrite_m && (i_rd_addr_m != 0) && (i_rd_addr_m == i_rs1_addr_d)) &&
            (i_rd_addr_w == i_rs1_addr_d))
            o_forward_a = 2'b01;

        if (i_regwrite_w && (i_rd_addr_w != 0) &&
            !(i_regwrite_m && (i_rd_addr_m != 0) && (i_rd_addr_m == i_rs2_addr_d)) &&
            (i_rd_addr_w == i_rs2_addr_d))
            o_forward_b = 2'b01;
    end

endmodule
